<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PDF Markup App</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    body {
      font-family: "Haas Grot Text R Web", "Helvetica Neue", Helvetica, Arial, sans-serif;
    }
    #toolbar {
      position: sticky;
      top: 0;
      z-index: 999;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px;
      flex-wrap: wrap;
    }
    .color-dot-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 5px;
      font-size: 12px;
    }
    .color-dot {
      width: 25px;
      height: 25px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
    }
    .selected {
      border-color: black;
    }
    #canvas-container {
      position: relative;
      overflow: auto;
      width: 100%;
      height: 80vh;
      border: 0px solid #ccc;
    }
    canvas {
      display: block;
    }
    .mark {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      pointer-events: none;
    }
    .reset-button {
      font-size: 10px;
      margin-top: 2px;
      cursor: pointer;
      color: blue;
      text-decoration: underline;
      border: none;
      background: none;
    }
    .button-1 {
      background-color: #2ea44f;
      border-radius: 8px;
      border-style: none;
      box-sizing: border-box;
      color: #FFFFFF;
      cursor: pointer;
      display: inline-block;
      font-family: "Haas Grot Text R Web", "Helvetica Neue", Helvetica, Arial, sans-serif;
      font-size: 14px;
      font-weight: 500;
      height: 40px;
      line-height: 20px;
      list-style: none;
      margin: 5px;
      outline: none;
      padding: 10px 16px;
      position: relative;
      text-align: center;
      text-decoration: none;
      transition: color 100ms;
      vertical-align: baseline;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    .button-1:hover {
      background-color: #ebdfb5;
      }
    .button-1:focus {
      background-color: #d6d6d6;
    }

    #zoom-level {
      margin-left: 10px;
      font-weight: bold;
    }
  #color-tools {
  position: fixed;
  top: 50%;
  left: 10px;
  transform: translateY(-50%);
  background-color: rgba(247, 247, 247, 0.7);
  padding: 10px;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  z-index: 1000;
  transition: transform 0.3s ease, opacity 0.3s ease;
}
</style>
</head>
<body>
  <div id="toolbar">
  <div id="color-tools"></div>
  <div id="button-group" style="width: 100%; text-align: center; margin-top: 10px;">
    <input type="file" id="upload" accept="application/pdf" class="button-1">
    <button onclick="savePDF()" class="button-1">Save Marked PDF</button>
    <button onclick="resetMarks()" class="button-1">Reset</button>
    <button onclick="zoomIn()" class="button-1">Zoom In</button>
    <button onclick="zoomOut()" class="button-1">Zoom Out</button>
    <button onclick="fitToScreen()" class="button-1">Fit to Screen</button>
    <button onclick="toggleFullscreen()" class="button-1">Fullscreen</button>
    <button onclick="previousPage()" class="button-1">Previous Page</button>
    <button onclick="nextPage()" class="button-1">Next Page</button>
    <button onclick="rotatePDF()" class="button-1">Rotate 90Â°</button>
    <span id="zoom-level">Zoom: 100%</span>
    <span id="page-info" style="margin-left: 10px; font-weight: bold;">Page: 1</span>
  </div>
</div>
<div id="canvas-container">
    <canvas id="pdf-canvas"></canvas>
  </div>

  <script>
    const colors = ['red', 'green', 'blue', 'orange', 'purple', 'cyan', 'magenta', 'yellow', 'black', 'gray'];
    const counts = {};
    const marks = {}; // pageNum => [{x, y, color}] stored in UNROTATED page coordinates
    let selectedColor = colors[0];
    let pdf = null, currentPage = 1, totalPages = 1, viewport = null, scale = 1;
    let rotation = 0; // 0, 90, 180, 270

    const toolbar = document.getElementById('color-tools');
    const container = document.getElementById('canvas-container');
    const canvas = document.getElementById('pdf-canvas');
    const ctx = canvas.getContext('2d');
    const zoomDisplay = document.getElementById('zoom-level');
    const pageInfo = document.getElementById('page-info');

    function updateZoomLevel() {
      zoomDisplay.textContent = `Zoom: ${Math.round(scale * 100)}%`;
    }

    function updatePageInfo() {
      pageInfo.textContent = `Page: ${currentPage}`;
    }

    function previousPage() {
      if (currentPage > 1) {
        currentPage--;
        fitToScreen();
      }
    }

    function nextPage() {
      if (currentPage < totalPages) {
        currentPage++;
        fitToScreen();
      }
    }

    // Build color tools
    colors.forEach(color => {
      const wrapper = document.createElement('div');
      wrapper.className = 'color-dot-wrapper';

      const dot = document.createElement('div');
      dot.className = 'color-dot';
      dot.style.backgroundColor = color;
      dot.dataset.color = color;
      if (color === selectedColor) dot.classList.add('selected');
      dot.onclick = () => {
        document.querySelectorAll('.color-dot').forEach(d => d.classList.remove('selected'));
        dot.classList.add('selected');
        selectedColor = color;
      };

      const label = document.createElement('input');
      label.type = 'text';
      label.value = `item ${colors.indexOf(color) + 1}`;
      label.style.marginTop = '5px';
      label.style.fontSize = '12px';
      label.style.textAlign = 'left';
      label.style.width = '60px';
      label.style.border = 'none';
      label.style.outline = 'none';
      label.style.background = 'transparent';

      const countText = document.createElement('div');
      countText.id = `count-${color}`;
      countText.textContent = '0';
      countText.style.fontSize = '20px';

      const resetBtn = document.createElement('button');
      resetBtn.textContent = 'Reset';
      resetBtn.className = 'reset-button';
      resetBtn.onclick = () => {
        if (!marks[currentPage]) return;
        marks[currentPage] = marks[currentPage].filter(m => m.color !== color);
        counts[color] = 0;
        updateCounts();
        renderPage(currentPage);
      };

      const dotLabelWrapper = document.createElement('div');
      dotLabelWrapper.style.display = 'flex';
      dotLabelWrapper.style.alignItems = 'center';
      dotLabelWrapper.style.gap = '8px';

      dotLabelWrapper.appendChild(dot);
      const labelContainer = document.createElement('div');
      labelContainer.style.display = 'block';
      const labelLine = document.createElement('div');
      labelLine.style.display = 'flex';
      labelLine.style.alignItems = 'center';
      labelLine.style.gap = '4px';
      labelLine.appendChild(label);
      labelLine.appendChild(countText);
      labelContainer.appendChild(labelLine);
      labelContainer.appendChild(resetBtn);
      dotLabelWrapper.appendChild(labelContainer);
      wrapper.appendChild(dotLabelWrapper);
      toolbar.appendChild(wrapper);

      counts[color] = 0;
    });

    function updateCounts() {
      colors.forEach(color => {
        document.getElementById(`count-${color}`).textContent = counts[color];
      });
    }

    document.getElementById('upload').addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file || file.type !== 'application/pdf') return;
      const reader = new FileReader();
      reader.onload = function () {
        const typedarray = new Uint8Array(this.result);
        pdfjsLib.getDocument(typedarray).promise.then(doc => {
          pdf = doc;
          totalPages = doc.numPages;
          currentPage = 1;
          fitToScreen();
        });
      };
      reader.readAsArrayBuffer(file);
    });

    function renderPage(pageNum) {
      pdf.getPage(pageNum).then(page => {
        // Base unrotated size for coordinate transforms
        const base = page.getViewport({ scale: 1, rotation: 0 });
        const baseW = base.width, baseH = base.height;

        // Rotation-aware viewport for rendering
        viewport = page.getViewport({ scale, rotation });
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        container.style.width = viewport.width + 'px';
        container.style.height = viewport.height + 'px';

        const renderContext = { canvasContext: ctx, viewport };
        page.render(renderContext).promise.then(() => {
          redrawMarks(baseW, baseH);
        });

        updateZoomLevel();
        updatePageInfo();
      });
    }

    function transformPoint(x, y, rot, w, h) {
      // x,y are in unrotated page coords; return rotated coords
      switch (rot % 360) {
        case 0: return { x, y };
        case 90: return { x: y, y: w - x };
        case 180: return { x: w - x, y: h - y };
        case 270: return { x: h - y, y: x };
        default: return { x, y };
      }
    }

    function inverseTransformPoint(xp, yp, rot, w, h) {
      // inverse of transformPoint
      switch (rot % 360) {
        case 0: return { x: xp, y: yp };
        case 90: return { x: w - yp, y: xp };
        case 180: return { x: w - xp, y: h - yp };
        case 270: return { x: yp, y: h - xp };
        default: return { x: xp, y: yp };
      }
    }

    function redrawMarks(baseW, baseH) {
      document.querySelectorAll('.mark').forEach(mark => mark.remove());
      if (!marks[currentPage]) return;
      marks[currentPage].forEach(({ x, y, color }) => {
        const p = transformPoint(x, y, rotation, baseW, baseH);
        const scaledX = p.x * scale;
        const scaledY = p.y * scale;
        const dot = document.createElement('div');
        dot.className = 'mark';
        dot.style.left = `${scaledX - 5}px`;
        dot.style.top = `${scaledY - 5}px`;
        dot.style.backgroundColor = color;
        container.appendChild(dot);
      });
    }

    container.addEventListener('click', e => {
      if (!pdf) return;
      pdf.getPage(currentPage).then(page => {
        const base = page.getViewport({ scale: 1, rotation: 0 });
        const rect = canvas.getBoundingClientRect();
        // coords in rotated, scaled space
        const xr = (e.clientX - rect.left) / scale;
        const yr = (e.clientY - rect.top) / scale;
        // map back to unrotated page coords for storage
        const p = inverseTransformPoint(xr, yr, rotation, base.width, base.height);

        if (!marks[currentPage]) marks[currentPage] = [];
        marks[currentPage].push({ x: p.x, y: p.y, color: selectedColor });
        counts[selectedColor]++;
        updateCounts();
        renderPage(currentPage);
      });
    });

    function resetMarks() {
      Object.keys(marks).forEach(page => marks[page] = []);
      colors.forEach(color => counts[color] = 0);
      updateCounts();
      renderPage(currentPage);
    }

    async function savePDF() {
      const { jsPDF } = window.jspdf;
      const firstPage = await pdf.getPage(1);
      const originalViewport = firstPage.getViewport({ scale: 2 });
      const pageWidth = originalViewport.width;
      const pageHeight = originalViewport.height;
      const pdfDoc = new jsPDF({ unit: 'px', format: [pageWidth, pageHeight] });

      const summaryLines = ['PDF Markup Summary'];
      colors.forEach(color => {
        const dotElement = document.querySelector(`.color-dot[data-color='${color}']`);
        const labelInput = dotElement?.closest('.color-dot-wrapper')?.querySelector('input');
        const label = labelInput && labelInput.value ? labelInput.value : `item ${colors.indexOf(color) + 1}`;
        if (counts[color] > 0) {
          summaryLines.push(`${label} (${color}): ${counts[color]}`);
        }
      });

      for (let i = 1; i <= totalPages; i++) {
        const page = await pdf.getPage(i);
        const viewport = page.getViewport({ scale: 1 });
        const canvasTemp = document.createElement('canvas');
        canvasTemp.width = viewport.width;
        canvasTemp.height = viewport.height;
        const ctxTemp = canvasTemp.getContext('2d');
        await page.render({ canvasContext: ctxTemp, viewport }).promise;

        const imgData = canvasTemp.toDataURL('image/jpeg');

        if (i !== 1) {
          pdfDoc.addPage([viewport.width, viewport.height]);
          pdfDoc.setPage(pdfDoc.getNumberOfPages());
        }
        pdfDoc.addImage(imgData, 'JPEG', 0, 0, viewport.width, viewport.height);

        if (i === 1) {
          pdfDoc.setFontSize(28);
          pdfDoc.setTextColor(0, 0, 0);
          let textY = 30;
          summaryLines.forEach(line => {
            pdfDoc.text(line, 10, textY);
            textY += 36;
          });
        }

        if (marks[i]) {
          marks[i].forEach(mark => {
            pdfDoc.setFillColor(mark.color);
            pdfDoc.circle(mark.x, mark.y, 5, 'F');
          });
        }
      }

      const now = new Date();
      const dateStr = now.toLocaleDateString('en-US').replace(/\//g, '-');
      const timeStr = now.toLocaleTimeString('en-US', { hour12: true }).replace(/:/g, '-').replace(/\s/g, '');
      const timestamp = `${dateStr}_${timeStr}`;
      const filename = `marked_${timestamp}.pdf`;
      pdfDoc.save(filename);
    }

    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === '+') {
        e.preventDefault();
        zoomIn();
      } else if (e.ctrlKey && e.key === '-') {
        e.preventDefault();
        zoomOut();
      }
    });

    function zoomIn() {
      scale = Math.min(scale + 0.1, 3);
      renderPage(currentPage);
    }

    function zoomOut() {
      scale = Math.max(scale - 0.1, 0.2);
      renderPage(currentPage);
    }

    function fitToScreen() {
      if (!pdf) return;
      pdf.getPage(currentPage).then(page => {
        const viewportUnscaled = page.getViewport({ scale: 1, rotation });
        const containerWidth = container.clientWidth;
        scale = containerWidth / viewportUnscaled.width;
        renderPage(currentPage);
      });
    }

    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        }
      }
    }

    function rotatePDF() {
      rotation = (rotation + 90) % 360;
      fitToScreen();
    }
  </script>

</body>
</html>
